@tool
class_name GaeaGenerator2D
extends GaeaGenerator

## Used to transform a world position into a map position,
## mainly used by the [ChunkLoader]. May also be used by
## a [GaeaRenderer]. Otherwise doesn't affect generation.
var tile_map: TileMap
@export var tile_size: Vector2i = Vector2i(16, 16)
@export var tile_shape: TileSet.TileShape
## Sets the generator to be used for the next pass. This generates a new grid on top of the one
## generated by this one.[br][br]
## If you're using a [GaeaRenderer], set its [param generator] to the last generator in the chain.[br]
## If you're using a [ChunkLoader2D], set its [param generator] to the first one.[br][br]
## [b]Note:[/b] Using modifiers instead of multiple generators is recommended. Only chain generators if necessary.
@export var next_pass: GaeaGenerator2D


func _ready() -> void:
	grid = GaeaGrid2D.new()
	super()


## Returns the [GaeaGrid2D] resource handling this generator's grid.
func get_grid() -> GaeaGrid2D:
	if not is_instance_valid(grid):
		grid = GaeaGrid2D.new()
	return grid


## Returns the map coordinates of the cell containing the given [param global_position].
func global_to_map(pos: Vector2) -> Vector2i:
	if tile_shape == TileSet.TILE_SHAPE_HEXAGON:
		return tile_map.local_to_map(pos)
	return (pos / Vector2(tile_size)).floor()


## Returns the global position of the cell at the given [param map_position].
func map_to_global(map_position: Vector2i) -> Vector2:
	return Vector2(map_position * tile_size)


func get_cells(actor_position: Vector2i, threshold: int, tile_map: TileMap) -> Array[Vector2i]:
	var cells: Dictionary = {actor_position: true}

	_get_cell_rings({actor_position: true}, cells, 0, threshold, tile_map)

	var cells_array: Array[Vector2i]
	cells_array.assign(cells.keys())

	return cells_array


func _get_cell_rings(
	inner_ring: Dictionary, cells: Dictionary, rings_processed: int, threshold: int, tile_map: TileMap
) -> void:
	var outer_ring: Dictionary = {}

	if rings_processed < threshold:
		for cell in inner_ring.keys():
			var neighbours: Array[Vector2i] = tile_map.get_surrounding_cells(cell)

			for neighbour in neighbours:
				if not cells.has(neighbour):
					cells[neighbour] = true
					outer_ring[neighbour] = true

		_get_cell_rings(outer_ring, cells, rings_processed + 1, threshold, tile_map)
